function [predictor, classification] = ...
    computePredictorAndClassification(positiveInstances, ...
    nNegativeExamples, gridSpacing, sectionSize)
%Computes a predictor and corresponding classification matrix from
%prelabeled images.
%   Uses the output of the Matlab training image labeler APP to generate
%   positive and negative examples for a maschine learning classifier.
%   Output from newer versions of the APP might require adaptation of the
%   code. Assumes that only on positive target section exists for each   
%   positive Instance. classification are the corresponding class labels
%   with 1 = positive classification and 0 = negative classification. One
%   positive target section per image is identified and a spaced grid of
%   negative examples is generated surrounding this target.
%      
%   INPUT
%   positiveInstances must be a struct with the fields 'ImageFilename' and
%       'objectBoundingBoxes' as generated by the Matlab training image.
%       labeler APP.
%   nNegativeExamples must be the square of a natural, non-zero number and 
%       indicates the maximum number of negative sections per image frame.
%   gridSpacing must be a non-zero natural number larger than 1 and is the 
%       pixel distance between the section in the grid of negative 
%       sections.
%   sectionSize must be a 1x2 array of two non-zero natural numbers
%       denoting the y,x size of the sections. sectionSize also needs to be
%       smaller than the dimensions of the frame.
%   
%   OUTPUT
%   predictor is a matrix in which each row (y dimension) is a linearized
%       section of an image.
%   classification denotes for the corresponding row in the predictor
%       whether it is a positive section (classification, 1) or not (0).

%% Validate input and preallocate.
if ~isfield(positiveInstances, 'imageFilename') || ...
        ~isfield(positiveInstances, 'objectBoundingBoxes') || ...
        isempty(positiveInstances(1).imageFilename)
    error('positiveInstances does not have the correct format or is empty')
end
validateattributes(sqrt(nNegativeExamples), {'numeric'}, {'integer', ...
    'positive'}, 'computePredictorAndClassification', ...
    'sqrt(nNegativeExamples)')
validateattributes(gridSpacing, {'numeric'}, {'positive', ...
    'integer','>', 1}, 'computePredictorAndClassification', 'gridSpacing')
validateattributes(sectionSize,{'numeric'},{'positive', 'integer', ...
    'size', [1,2]}, 'computePredictorAndClassification', 'sectionSize')

gridSize = sqrt(nNegativeExamples);
predictor = zeros((nNegativeExamples+1)...
    *length(positiveInstances), prod(sectionSize), 'uint8');
classification = zeros((nNegativeExamples+1)...
    *length(positiveInstances), 1, 'uint8');
sectionCount = 0;
for iFrame = 1:size(positiveInstances,2);
    imageFrame = imread(positiveInstances(iFrame).imageFilename);
    assert(min(size(imageFrame)-sectionSize) >= 0, ...
        'sectionSize is too large')
    
    %% Identify the 1 positive section from the positive instances.
    sectionCount = sectionCount + 1;
    classification(sectionCount, 1) = 1;
    [section, centerOrigin] = identifyPositiveSection(imageFrame, ...
        positiveInstances(iFrame).objectBoundingBoxes, sectionSize);
    predictor(sectionCount, :) = section(:);
    
    %% Supply a maximum of nNegativeExamples negative sections.
    gridPredictor = computeGridPredictor(gridSpacing, gridSize, ...
        centerOrigin, imageFrame, sectionSize);
    sectionCount = sectionCount+1;
    predictor(sectionCount:sectionCount+size(gridPredictor,1)-1, :) ...
        = gridPredictor;
    classification(sectionCount:sectionCount+size(gridPredictor,1)-1, 1)...
        = 0;
    sectionCount = sectionCount + size(gridPredictor,1) - 1;
end

classification(sum(predictor,2) == 0, :) = [];
predictor(sum(predictor,2) == 0, :) = [];

classification = logical(classification);
predictor = single(predictor);

end